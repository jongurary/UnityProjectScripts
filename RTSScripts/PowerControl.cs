using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PowerControl : MonoBehaviour {

	public int watts; //power output per second of the generator, in "watts", !!usually set by an external script!!
	public int maxWattHours; //maximum watt-hour storage of the generator's internal battery
	//Note: amperage is handled by the linkage script

	private int voltage = Constants.VOLTAGE_DEFAULT; //everything uses a standard value of 100 volts
	public int wattsStored; //current watt-hours stored, initialized to zero

	private float generationSpeed =1f; //Reactors generate power once per second, this is universal among all devices

	private ResourceManager resManager; //tracks the total power in the economy


	void Start () {
		wattsStored = 0;
		StartCoroutine(generate(generationSpeed));
		//register this object with the resource manager
		resManager = GameObject.FindGameObjectWithTag("ResourceManager").GetComponent<ResourceManager>();
		resManager.addPowerController ( GetComponent<PowerControl>() );
	}

	//Unregister with the resource manager on destruction
	void OnDestroy()
	{
		resManager.removePowerController ( GetComponent<PowerControl>() );
	}

	void Update () {
		
	}

	IEnumerator generate(float waitTime) {
		while (true) {
			yield return new WaitForSeconds (waitTime);
			charge (watts);
		}
	}

/// <summary>
/// Pump watt-hours into the system, returns true if unit did recieve power, false if failed
/// </summary>
/// <param name="toCharge">Amount to charge.</param>
	public bool charge(int toCharge){
		if (wattsStored <= maxWattHours - toCharge) {
			wattsStored = wattsStored + toCharge;
			return true;
		} else {
			return false;
		}
	}

/// <summary>
///	Drain watt-hours from system, returns true if unit can give power, false if not, but still drains charge into negatives
/// </summary>
/// <param name="toCharge">Watts to drain.</param>
	public bool drain(int toCharge){
		wattsStored = wattsStored - toCharge; //a negative charge indicates an error, but drains must always be applied
		if (wattsStored >= toCharge) {
			return true;
		} else {
			return false;
		}
	}

/// <summary>
/// Test if a charge will render this unit overfull, without applying the charge, returns true if would be overfull
/// </summary>
/// <returns><c>true</c>, if overfull with charge <c>false</c> otherwise.</returns>
/// <param name="toCharge">Watts to charge.</param>
	public bool isFull(int toCharge){
		if (wattsStored + toCharge > maxWattHours) {
			return true;
		} else {
			return false;
		}
	}
	
/// <summary>
/// Test if a drain would render this unit negatively charged, without draining the charge, returns true if would be negative
/// </summary>
/// <returns><c>true</c>, if would be negative <c>false</c> otherwise.</returns>
/// <param name="toCharge">Watts to drain.</param>
	public bool isEmpty(int toCharge){
		if (wattsStored > toCharge) {
			return false;
		} else {
			return true;
		}
	}


	//TODO power overloaded (beyond max?)

	/// <summary>
	/// Returns the watts per second generated by this system
	/// </summary>
	public int getWatts(){ return watts; }
	/// <summary>
	/// Sets watts per second generated by this system
	/// </summary>
	public void setWatts(int toSet){ watts = toSet; return; }
	/// <summary>
	/// Maximum stored watt-hours
	/// </summary>
	public int getMaxWattHours(){ return maxWattHours; }
	/// <summary>
	/// Currently stored watt-hours
	/// </summary>
	public int getCurrentWattHours(){ return wattsStored; }
}
